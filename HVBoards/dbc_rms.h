/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


/**
 * This file was generated by cantools version 37.0.1 Mon Dec 27 21:13:46 2021.
 */

#ifndef DBC_RMS_H
#define DBC_RMS_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include "DecentralizedLV-Boards/HVBoards/canstruct.h"

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define DBC_RMS_M173_MODULATION_AND_FLUX_INFO_FRAME_ID (0xadu)
#define DBC_RMS_M172_TORQUE_AND_TIMER_INFO_FRAME_ID (0xacu)
#define DBC_RMS_M194_READ_WRITE_PARAM_RESPONSE_FRAME_ID (0xc2u)
#define DBC_RMS_M193_READ_WRITE_PARAM_COMMAND_FRAME_ID (0xc1u)
#define DBC_RMS_M192_COMMAND_MESSAGE_FRAME_ID (0xc0u)
#define DBC_RMS_M171_FAULT_CODES_FRAME_ID (0xabu)
#define DBC_RMS_M170_INTERNAL_STATES_FRAME_ID (0xaau)
#define DBC_RMS_M169_INTERNAL_VOLTAGES_FRAME_ID (0xa9u)
#define DBC_RMS_M168_FLUX_ID_IQ_INFO_FRAME_ID (0xa8u)
#define DBC_RMS_M167_VOLTAGE_INFO_FRAME_ID (0xa7u)
#define DBC_RMS_M166_CURRENT_INFO_FRAME_ID (0xa6u)
#define DBC_RMS_M165_MOTOR_POSITION_INFO_FRAME_ID (0xa5u)
#define DBC_RMS_M164_DIGITAL_INPUT_STATUS_FRAME_ID (0xa4u)
#define DBC_RMS_M163_ANALOG_INPUT_VOLTAGES_FRAME_ID (0xa3u)
#define DBC_RMS_M162_TEMPERATURE_SET_3_FRAME_ID (0xa2u)
#define DBC_RMS_M161_TEMPERATURE_SET_2_FRAME_ID (0xa1u)
#define DBC_RMS_M160_TEMPERATURE_SET_1_FRAME_ID (0xa0u)
#define DBC_RMS_M174_FIRMWARE_INFO_FRAME_ID (0xaeu)
#define DBC_RMS_M175_DIAG_DATA_FRAME_ID (0xafu)
#define DBC_RMS_M187_U2_C_COMMAND_TXD_FRAME_ID (0x1d7u)
#define DBC_RMS_M188_U2_C_MESSAGE_RXD_FRAME_ID (0x1d5u)
#define DBC_RMS_BMS_CURRENT_LIMIT_FRAME_ID (0x202u)
#define DBC_RMS_M176_FAST_INFO_FRAME_ID (0xb0u)

/* Frame lengths in bytes. */
#define DBC_RMS_M173_MODULATION_AND_FLUX_INFO_LENGTH (8u)
#define DBC_RMS_M172_TORQUE_AND_TIMER_INFO_LENGTH (8u)
#define DBC_RMS_M194_READ_WRITE_PARAM_RESPONSE_LENGTH (8u)
#define DBC_RMS_M193_READ_WRITE_PARAM_COMMAND_LENGTH (8u)
#define DBC_RMS_M192_COMMAND_MESSAGE_LENGTH (8u)
#define DBC_RMS_M171_FAULT_CODES_LENGTH (8u)
#define DBC_RMS_M170_INTERNAL_STATES_LENGTH (8u)
#define DBC_RMS_M169_INTERNAL_VOLTAGES_LENGTH (8u)
#define DBC_RMS_M168_FLUX_ID_IQ_INFO_LENGTH (8u)
#define DBC_RMS_M167_VOLTAGE_INFO_LENGTH (8u)
#define DBC_RMS_M166_CURRENT_INFO_LENGTH (8u)
#define DBC_RMS_M165_MOTOR_POSITION_INFO_LENGTH (8u)
#define DBC_RMS_M164_DIGITAL_INPUT_STATUS_LENGTH (8u)
#define DBC_RMS_M163_ANALOG_INPUT_VOLTAGES_LENGTH (8u)
#define DBC_RMS_M162_TEMPERATURE_SET_3_LENGTH (8u)
#define DBC_RMS_M161_TEMPERATURE_SET_2_LENGTH (8u)
#define DBC_RMS_M160_TEMPERATURE_SET_1_LENGTH (8u)
#define DBC_RMS_M174_FIRMWARE_INFO_LENGTH (8u)
#define DBC_RMS_M175_DIAG_DATA_LENGTH (8u)
#define DBC_RMS_M187_U2_C_COMMAND_TXD_LENGTH (8u)
#define DBC_RMS_M188_U2_C_MESSAGE_RXD_LENGTH (8u)
#define DBC_RMS_BMS_CURRENT_LIMIT_LENGTH (8u)
#define DBC_RMS_M176_FAST_INFO_LENGTH (8u)

/* Extended or standard frame types. */
#define DBC_RMS_M173_MODULATION_AND_FLUX_INFO_IS_EXTENDED (0)
#define DBC_RMS_M172_TORQUE_AND_TIMER_INFO_IS_EXTENDED (0)
#define DBC_RMS_M194_READ_WRITE_PARAM_RESPONSE_IS_EXTENDED (0)
#define DBC_RMS_M193_READ_WRITE_PARAM_COMMAND_IS_EXTENDED (0)
#define DBC_RMS_M192_COMMAND_MESSAGE_IS_EXTENDED (0)
#define DBC_RMS_M171_FAULT_CODES_IS_EXTENDED (0)
#define DBC_RMS_M170_INTERNAL_STATES_IS_EXTENDED (0)
#define DBC_RMS_M169_INTERNAL_VOLTAGES_IS_EXTENDED (0)
#define DBC_RMS_M168_FLUX_ID_IQ_INFO_IS_EXTENDED (0)
#define DBC_RMS_M167_VOLTAGE_INFO_IS_EXTENDED (0)
#define DBC_RMS_M166_CURRENT_INFO_IS_EXTENDED (0)
#define DBC_RMS_M165_MOTOR_POSITION_INFO_IS_EXTENDED (0)
#define DBC_RMS_M164_DIGITAL_INPUT_STATUS_IS_EXTENDED (0)
#define DBC_RMS_M163_ANALOG_INPUT_VOLTAGES_IS_EXTENDED (0)
#define DBC_RMS_M162_TEMPERATURE_SET_3_IS_EXTENDED (0)
#define DBC_RMS_M161_TEMPERATURE_SET_2_IS_EXTENDED (0)
#define DBC_RMS_M160_TEMPERATURE_SET_1_IS_EXTENDED (0)
#define DBC_RMS_M174_FIRMWARE_INFO_IS_EXTENDED (0)
#define DBC_RMS_M175_DIAG_DATA_IS_EXTENDED (0)
#define DBC_RMS_M187_U2_C_COMMAND_TXD_IS_EXTENDED (0)
#define DBC_RMS_M188_U2_C_MESSAGE_RXD_IS_EXTENDED (0)
#define DBC_RMS_BMS_CURRENT_LIMIT_IS_EXTENDED (0)
#define DBC_RMS_M176_FAST_INFO_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define DBC_RMS_M172_TORQUE_AND_TIMER_INFO_CYCLE_TIME_MS (10u)
#define DBC_RMS_M192_COMMAND_MESSAGE_CYCLE_TIME_MS (5u)
#define DBC_RMS_M171_FAULT_CODES_CYCLE_TIME_MS (100u)
#define DBC_RMS_M170_INTERNAL_STATES_CYCLE_TIME_MS (100u)
#define DBC_RMS_M169_INTERNAL_VOLTAGES_CYCLE_TIME_MS (100u)
#define DBC_RMS_M168_FLUX_ID_IQ_INFO_CYCLE_TIME_MS (10u)
#define DBC_RMS_M167_VOLTAGE_INFO_CYCLE_TIME_MS (10u)
#define DBC_RMS_M166_CURRENT_INFO_CYCLE_TIME_MS (10u)
#define DBC_RMS_M165_MOTOR_POSITION_INFO_CYCLE_TIME_MS (10u)
#define DBC_RMS_M164_DIGITAL_INPUT_STATUS_CYCLE_TIME_MS (10u)
#define DBC_RMS_M163_ANALOG_INPUT_VOLTAGES_CYCLE_TIME_MS (10u)
#define DBC_RMS_M162_TEMPERATURE_SET_3_CYCLE_TIME_MS (100u)
#define DBC_RMS_M161_TEMPERATURE_SET_2_CYCLE_TIME_MS (100u)
#define DBC_RMS_M160_TEMPERATURE_SET_1_CYCLE_TIME_MS (100u)
#define DBC_RMS_M176_FAST_INFO_CYCLE_TIME_MS (3u)

/* Signal choices. */
#define DBC_RMS_M192_COMMAND_MESSAGE_DIRECTION_COMMAND_CW_CHOICE (0u)
#define DBC_RMS_M192_COMMAND_MESSAGE_DIRECTION_COMMAND_CCW_CHOICE (1u)

#define DBC_RMS_M192_COMMAND_MESSAGE_INVERTER_ENABLE_TURN_THE_INVERTER_OFF_CHOICE (0u)
#define DBC_RMS_M192_COMMAND_MESSAGE_INVERTER_ENABLE_TURN_THE__INVERTER_ON_CHOICE (1u)

#define DBC_RMS_M192_COMMAND_MESSAGE_INVERTER_DISCHARGE_DISCHARGE__DISABLE_CHOICE (0u)
#define DBC_RMS_M192_COMMAND_MESSAGE_INVERTER_DISCHARGE_DISCHARGE__ENABLE__IF_EEPROM_PARAMETER_IS_SET__CHOICE (1u)

#define DBC_RMS_M170_INTERNAL_STATES_D1_VSM_STATE_VSM__START__STATE_CHOICE (0u)
#define DBC_RMS_M170_INTERNAL_STATES_D1_VSM_STATE_PRE__CHARGE__INIT_STATE_CHOICE (1u)
#define DBC_RMS_M170_INTERNAL_STATES_D1_VSM_STATE_PRE_CHARGE_ACTIVE_STATE_CHOICE (2u)
#define DBC_RMS_M170_INTERNAL_STATES_D1_VSM_STATE_PRE_CHARGE_COMPLETE_STATE_CHOICE (3u)
#define DBC_RMS_M170_INTERNAL_STATES_D1_VSM_STATE_VSM_WAIT_STATE_CHOICE (4u)
#define DBC_RMS_M170_INTERNAL_STATES_D1_VSM_STATE_VSM_READY_STATE_CHOICE (5u)
#define DBC_RMS_M170_INTERNAL_STATES_D1_VSM_STATE_MOTOR__RUNNING__STATE_CHOICE (6u)
#define DBC_RMS_M170_INTERNAL_STATES_D1_VSM_STATE_BLINK_FAULT_CODE_STATE_CHOICE (7u)
#define DBC_RMS_M170_INTERNAL_STATES_D1_VSM_STATE_SHUTDOWN_STATE_FOR__KEY__SWITCH__MODE_1_CHOICE (14u)
#define DBC_RMS_M170_INTERNAL_STATES_D1_VSM_STATE_RESET_THE_INVERTER_CHOICE (15u)

#define DBC_RMS_M170_INTERNAL_STATES_D2_INVERTER_STATE_POWER_UP_CHOICE (0u)
#define DBC_RMS_M170_INTERNAL_STATES_D2_INVERTER_STATE_STOP_CHOICE (1u)
#define DBC_RMS_M170_INTERNAL_STATES_D2_INVERTER_STATE_OPEN__LOOP_CHOICE (2u)
#define DBC_RMS_M170_INTERNAL_STATES_D2_INVERTER_STATE_CLOSED__LOOP_CHOICE (3u)
#define DBC_RMS_M170_INTERNAL_STATES_D2_INVERTER_STATE_INTERNAL__STATE_4_CHOICE (4u)
#define DBC_RMS_M170_INTERNAL_STATES_D2_INVERTER_STATE_INTERNAL__STATE_5_CHOICE (5u)
#define DBC_RMS_M170_INTERNAL_STATES_D2_INVERTER_STATE_INTERNAL__STATE_6_CHOICE (6u)
#define DBC_RMS_M170_INTERNAL_STATES_D2_INVERTER_STATE_INTERNAL__STATE_7_CHOICE (7u)
#define DBC_RMS_M170_INTERNAL_STATES_D2_INVERTER_STATE_IDLE__RUN_CHOICE (8u)
#define DBC_RMS_M170_INTERNAL_STATES_D2_INVERTER_STATE_IDLE__STOP_CHOICE (9u)
#define DBC_RMS_M170_INTERNAL_STATES_D2_INVERTER_STATE_INTERNAL__STATE_10_CHOICE (10u)
#define DBC_RMS_M170_INTERNAL_STATES_D2_INVERTER_STATE_INTERN__STATE_CHOICE (11u)
#define DBC_RMS_M170_INTERNAL_STATES_D2_INVERTER_STATE_INTERNAL__STATE_12_CHOICE (12u)


/**
 * Signals in message M173_Modulation_And_Flux_Info.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m173_modulation_and_flux_info_t:public CAN_STRUCT {
    /**
     * This is the modulation index. The scale factor is x100. To get the actual modulation index divide the value by 100.
     *
     * Range: -32768..32767 (-3.2768..3.2767 -)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t d1_modulation_index;

    /**
     * This is the current output of the flux regulator.
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d2_flux_weakening_output;

    /**
     * The commanded D-axis current
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d3_id_command;

    /**
     * The commanded Q-axis current
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d4_iq_command;

    /**
    * Encode member
    */
    int16_t d1_modulation_index_encode();

    /**
    * Decode member
    */
    double d1_modulation_index_decode();

    /**
    * Is in range member
    */
    bool d1_modulation_index_is_in_range();


    /**
    * Encode member
    */
    int16_t d2_flux_weakening_output_encode();

    /**
    * Decode member
    */
    double d2_flux_weakening_output_decode();

    /**
    * Is in range member
    */
    bool d2_flux_weakening_output_is_in_range();


    /**
    * Encode member
    */
    int16_t d3_id_command_encode();

    /**
    * Decode member
    */
    double d3_id_command_decode();

    /**
    * Is in range member
    */
    bool d3_id_command_is_in_range();


    /**
    * Encode member
    */
    int16_t d4_iq_command_encode();

    /**
    * Decode member
    */
    double d4_iq_command_decode();

    /**
    * Is in range member
    */
    bool d4_iq_command_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M172_Torque_And_Timer_Info.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m172_torque_and_timer_info_t:public CAN_STRUCT {
    /**
     * The commanded Torque
     *
     * Range: -32768..32767 (-3276.8..3276.7 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d1_commanded_torque;

    /**
     * Estimated motor torque feedback
     *
     * Range: -32768..32767 (-3276.8..3276.7 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d2_torque_feedback;

    /**
     * Updated every 3 msec. This will roll over in approximately 150 days!
     *
     * Range: 0..4294933333.333333333333333333 (0..12884800 Sec)
     * Scale: 0.003
     * Offset: 0
     */
    uint32_t d3_power_on_timer;

    /**
    * Encode member
    */
    int16_t d1_commanded_torque_encode();

    /**
    * Decode member
    */
    double d1_commanded_torque_decode();

    /**
    * Is in range member
    */
    bool d1_commanded_torque_is_in_range();


    /**
    * Encode member
    */
    int16_t d2_torque_feedback_encode();

    /**
    * Decode member
    */
    double d2_torque_feedback_decode();

    /**
    * Is in range member
    */
    bool d2_torque_feedback_is_in_range();


    /**
    * Encode member
    */
    uint32_t d3_power_on_timer_encode();

    /**
    * Decode member
    */
    double d3_power_on_timer_decode();

    /**
    * Is in range member
    */
    bool d3_power_on_timer_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M194_Read_Write_Param_Response.
 *
 * The inverter response to each Parameter message that is received.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m194_read_write_param_response_t:public CAN_STRUCT {
    /**
     * Valid EEPROM Parameter CAN addresses are between 100 and 499.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t d1_parameter_address_response;

    /**
     * 0=Write failure, 1=Success
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d2_write_success;

    /**
     * All EEPROM data is 16 bits and is contained in bytes 4 and 5. Bytes 6 and 7 should be ignored.
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t d3_data_response;

    /**
    * Encode member
    */
    uint16_t d1_parameter_address_response_encode();

    /**
    * Decode member
    */
    double d1_parameter_address_response_decode();

    /**
    * Is in range member
    */
    bool d1_parameter_address_response_is_in_range();


    /**
    * Encode member
    */
    uint8_t d2_write_success_encode();

    /**
    * Decode member
    */
    double d2_write_success_decode();

    /**
    * Is in range member
    */
    bool d2_write_success_is_in_range();


    /**
    * Encode member
    */
    int16_t d3_data_response_encode();

    /**
    * Decode member
    */
    double d3_data_response_decode();

    /**
    * Is in range member
    */
    bool d3_data_response_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M193_Read_Write_Param_Command.
 *
 * Parameter Message sent as needed by VCU to request info, change EEPROM, or command a function.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m193_read_write_param_command_t:public CAN_STRUCT {
    /**
     * Valid EEPROM Parameter CAN addresses are between 100 and 499.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t d1_parameter_address_command;

    /**
     * 0=Read, 1=Write
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d2_read_write_command;

    /**
     * All EEPROM data is 16 bits and is contained in bytes 4 and 5.
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t d3_data_command;

    /**
    * Encode member
    */
    uint16_t d1_parameter_address_command_encode();

    /**
    * Decode member
    */
    double d1_parameter_address_command_decode();

    /**
    * Is in range member
    */
    bool d1_parameter_address_command_is_in_range();


    /**
    * Encode member
    */
    uint8_t d2_read_write_command_encode();

    /**
    * Decode member
    */
    double d2_read_write_command_decode();

    /**
    * Is in range member
    */
    bool d2_read_write_command_is_in_range();


    /**
    * Encode member
    */
    int16_t d3_data_command_encode();

    /**
    * Decode member
    */
    double d3_data_command_decode();

    /**
    * Is in range member
    */
    bool d3_data_command_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M192_Command_Message.
 *
 * The command message is used to transmit data to the controller. This message is sent from a user supplied external controller to the PMxxx controller.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m192_command_message_t:public CAN_STRUCT {
    /**
     * Torque command when in torque mode
     *
     * Range: -32768..32767 (-3276.8..3276.7 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t torque_command;

    /**
     * Speed commandused when in speed mode
     *
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t speed_command;

    /**
     * 0=CW, 1=CCW as veiwed from the shaft end of the motor
     *
     * Range: 0..1 (0..1 Bit)
     * Scale: 1
     * Offset: 0
     */
    uint8_t direction_command;

    /**
     * 0=Inverter OFF, 1 = Inverter ON
     *
     * Range: 0..1 (0..1 Bit)
     * Scale: 1
     * Offset: 0
     */
    uint8_t inverter_enable;

    /**
     * 0=Discharge Disable,
     * =Discharge Enable
     *
     * Range: 0..1 (0..1 Bit)
     * Scale: 1
     * Offset: 0
     */
    uint8_t inverter_discharge;

    /**
     * 0 = No change to mode, 1 = change to speed mode from torque mode
     *
     * Range: 0..1 (0..1 Bit)
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_mode_enable;

    /**
     * Rolling Counter command
     *
     * Range: 0..15 (0..15 Bits)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rolling_counter;

    /**
     * Torque Limit, set to 0 to keep default
     *
     * Range: -32768..32767 (-3276.8..3276.7 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t torque_limit_command;

    /**
    * Encode member
    */
    int16_t torque_command_encode();

    /**
    * Decode member
    */
    double torque_command_decode();

    /**
    * Is in range member
    */
    bool torque_command_is_in_range();


    /**
    * Encode member
    */
    int16_t speed_command_encode();

    /**
    * Decode member
    */
    double speed_command_decode();

    /**
    * Is in range member
    */
    bool speed_command_is_in_range();


    /**
    * Encode member
    */
    uint8_t direction_command_encode();

    /**
    * Decode member
    */
    double direction_command_decode();

    /**
    * Is in range member
    */
    bool direction_command_is_in_range();


    /**
    * Encode member
    */
    uint8_t inverter_enable_encode();

    /**
    * Decode member
    */
    double inverter_enable_decode();

    /**
    * Is in range member
    */
    bool inverter_enable_is_in_range();


    /**
    * Encode member
    */
    uint8_t inverter_discharge_encode();

    /**
    * Decode member
    */
    double inverter_discharge_decode();

    /**
    * Is in range member
    */
    bool inverter_discharge_is_in_range();


    /**
    * Encode member
    */
    uint8_t speed_mode_enable_encode();

    /**
    * Decode member
    */
    double speed_mode_enable_decode();

    /**
    * Is in range member
    */
    bool speed_mode_enable_is_in_range();


    /**
    * Encode member
    */
    uint8_t rolling_counter_encode();

    /**
    * Decode member
    */
    double rolling_counter_decode();

    /**
    * Is in range member
    */
    bool rolling_counter_is_in_range();


    /**
    * Encode member
    */
    int16_t torque_limit_command_encode();

    /**
    * Decode member
    */
    double torque_limit_command_decode();

    /**
    * Is in range member
    */
    bool torque_limit_command_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M171_Fault_Codes.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m171_fault_codes_t:public CAN_STRUCT {
    /**
     * Each bit represents a fault. Please refer to PM100 Users Manual for details.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t d1_post_fault_lo;

    /**
     * Each bit represents a fault. Please refer to PM100 Users Manual for details.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t d2_post_fault_hi;

    /**
     * Each bit represents a fault. Please refer to PM100 Users Manual for details.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t d3_run_fault_lo;

    /**
     * Each bit represents a fault. Please refer to PM100 Users Manual for details.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t d4_run_fault_hi;

    /**
    * Encode member
    */
    uint16_t d1_post_fault_lo_encode();

    /**
    * Decode member
    */
    double d1_post_fault_lo_decode();

    /**
    * Is in range member
    */
    bool d1_post_fault_lo_is_in_range();


    /**
    * Encode member
    */
    uint16_t d2_post_fault_hi_encode();

    /**
    * Decode member
    */
    double d2_post_fault_hi_decode();

    /**
    * Is in range member
    */
    bool d2_post_fault_hi_is_in_range();


    /**
    * Encode member
    */
    uint16_t d3_run_fault_lo_encode();

    /**
    * Decode member
    */
    double d3_run_fault_lo_decode();

    /**
    * Is in range member
    */
    bool d3_run_fault_lo_is_in_range();


    /**
    * Encode member
    */
    uint16_t d4_run_fault_hi_encode();

    /**
    * Decode member
    */
    double d4_run_fault_hi_decode();

    /**
    * Is in range member
    */
    bool d4_run_fault_hi_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M170_Internal_States.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m170_internal_states_t:public CAN_STRUCT {
    /**
     * Different states for the vehicle state machine
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d1_vsm_state;

    /**
     * The inverter PWM frequency
     *
     * Range: 0..255 (0..255 kHz)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d1_pwm_frequency;

    /**
     * Different states for the inverter state machine
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d2_inverter_state;

    /**
     * 0=OFF, 1=ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d3_relay_1_status;

    /**
     * 0=OFF, 1=ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d3_relay_2_status;

    /**
     * 0=OFF, 1=ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d3_relay_3_status;

    /**
     * 0=OFF, 1=ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d3_relay_4_status;

    /**
     * 0=OFF, 1=ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d3_relay_5_status;

    /**
     * 0=OFF, 1=ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d3_relay_6_status;

    /**
     * 0=Torque Mode, 1=Speed Mode
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d4_inverter_run_mode;

    /**
     * 0 = Disabled, 1 = Enabled, 2 = Speed Check, 3 = Active, 4 = Complete
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d4_inverter_discharge_state;

    /**
     * 0=CAN mode, 1=VSM mode
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d5_inverter_command_mode;

    /**
     * The current rolling counter value.
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d5_rolling_counter;

    /**
     * 0=Inverter Disabled,
     * 1=Inverter Enabled
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d6_inverter_enable_state;

    /**
     * 0=Lockout Disabled, 1=Lockout Enabled
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d6_inverter_enable_lockout;

    /**
     * 1 = Forward
     * 0 = 'Reverse' if inverter enabled  & 'Stopped' if inverter is disabled
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d7_direction_command;

    /**
     * 0 = BMS Not Active, 1 = BMS Active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d7_bms_active;

    /**
     * 0 = Not Limiting, 1 = Limiting
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d7_bms_torque_limiting;

    /**
     * 0 = Not Limiting, 1 = torque limiting due to maximum speed
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d7_max_speed_limiting;

    /**
     * 0 = Not Limiting, 1 = Current limiting due to low motor speed
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d7_low_speed_limiting;

    /**
    * Encode member
    */
    uint8_t d1_vsm_state_encode();

    /**
    * Decode member
    */
    double d1_vsm_state_decode();

    /**
    * Is in range member
    */
    bool d1_vsm_state_is_in_range();


    /**
    * Encode member
    */
    uint8_t d1_pwm_frequency_encode();

    /**
    * Decode member
    */
    double d1_pwm_frequency_decode();

    /**
    * Is in range member
    */
    bool d1_pwm_frequency_is_in_range();


    /**
    * Encode member
    */
    uint8_t d2_inverter_state_encode();

    /**
    * Decode member
    */
    double d2_inverter_state_decode();

    /**
    * Is in range member
    */
    bool d2_inverter_state_is_in_range();


    /**
    * Encode member
    */
    uint8_t d3_relay_1_status_encode();

    /**
    * Decode member
    */
    double d3_relay_1_status_decode();

    /**
    * Is in range member
    */
    bool d3_relay_1_status_is_in_range();


    /**
    * Encode member
    */
    uint8_t d3_relay_2_status_encode();

    /**
    * Decode member
    */
    double d3_relay_2_status_decode();

    /**
    * Is in range member
    */
    bool d3_relay_2_status_is_in_range();


    /**
    * Encode member
    */
    uint8_t d3_relay_3_status_encode();

    /**
    * Decode member
    */
    double d3_relay_3_status_decode();

    /**
    * Is in range member
    */
    bool d3_relay_3_status_is_in_range();


    /**
    * Encode member
    */
    uint8_t d3_relay_4_status_encode();

    /**
    * Decode member
    */
    double d3_relay_4_status_decode();

    /**
    * Is in range member
    */
    bool d3_relay_4_status_is_in_range();


    /**
    * Encode member
    */
    uint8_t d3_relay_5_status_encode();

    /**
    * Decode member
    */
    double d3_relay_5_status_decode();

    /**
    * Is in range member
    */
    bool d3_relay_5_status_is_in_range();


    /**
    * Encode member
    */
    uint8_t d3_relay_6_status_encode();

    /**
    * Decode member
    */
    double d3_relay_6_status_decode();

    /**
    * Is in range member
    */
    bool d3_relay_6_status_is_in_range();


    /**
    * Encode member
    */
    uint8_t d4_inverter_run_mode_encode();

    /**
    * Decode member
    */
    double d4_inverter_run_mode_decode();

    /**
    * Is in range member
    */
    bool d4_inverter_run_mode_is_in_range();


    /**
    * Encode member
    */
    uint8_t d4_inverter_discharge_state_encode();

    /**
    * Decode member
    */
    double d4_inverter_discharge_state_decode();

    /**
    * Is in range member
    */
    bool d4_inverter_discharge_state_is_in_range();


    /**
    * Encode member
    */
    uint8_t d5_inverter_command_mode_encode();

    /**
    * Decode member
    */
    double d5_inverter_command_mode_decode();

    /**
    * Is in range member
    */
    bool d5_inverter_command_mode_is_in_range();


    /**
    * Encode member
    */
    uint8_t d5_rolling_counter_encode();

    /**
    * Decode member
    */
    double d5_rolling_counter_decode();

    /**
    * Is in range member
    */
    bool d5_rolling_counter_is_in_range();


    /**
    * Encode member
    */
    uint8_t d6_inverter_enable_state_encode();

    /**
    * Decode member
    */
    double d6_inverter_enable_state_decode();

    /**
    * Is in range member
    */
    bool d6_inverter_enable_state_is_in_range();


    /**
    * Encode member
    */
    uint8_t d6_inverter_enable_lockout_encode();

    /**
    * Decode member
    */
    double d6_inverter_enable_lockout_decode();

    /**
    * Is in range member
    */
    bool d6_inverter_enable_lockout_is_in_range();


    /**
    * Encode member
    */
    uint8_t d7_direction_command_encode();

    /**
    * Decode member
    */
    double d7_direction_command_decode();

    /**
    * Is in range member
    */
    bool d7_direction_command_is_in_range();


    /**
    * Encode member
    */
    uint8_t d7_bms_active_encode();

    /**
    * Decode member
    */
    double d7_bms_active_decode();

    /**
    * Is in range member
    */
    bool d7_bms_active_is_in_range();


    /**
    * Encode member
    */
    uint8_t d7_bms_torque_limiting_encode();

    /**
    * Decode member
    */
    double d7_bms_torque_limiting_decode();

    /**
    * Is in range member
    */
    bool d7_bms_torque_limiting_is_in_range();


    /**
    * Encode member
    */
    uint8_t d7_max_speed_limiting_encode();

    /**
    * Decode member
    */
    double d7_max_speed_limiting_decode();

    /**
    * Is in range member
    */
    bool d7_max_speed_limiting_is_in_range();


    /**
    * Encode member
    */
    uint8_t d7_low_speed_limiting_encode();

    /**
    * Decode member
    */
    double d7_low_speed_limiting_decode();

    /**
    * Is in range member
    */
    bool d7_low_speed_limiting_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M169_Internal_Voltages.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m169_internal_voltages_t:public CAN_STRUCT {
    /**
     * Internal reference voltage
     *
     * Range: -32768..32767 (-327.68..327.67 V)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t d1_reference_voltage_1_5;

    /**
     * Internal reference voltage
     *
     * Range: -32768..32767 (-327.68..327.67 V)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t d2_reference_voltage_2_5;

    /**
     * Transducer voltage
     *
     * Range: -32768..32767 (-327.68..327.67 V)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t d3_reference_voltage_5_0;

    /**
     * 12V Input Voltage
     *
     * Range: -32768..32767 (-327.68..327.67 V)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t d4_reference_voltage_12_0;

    /**
    * Encode member
    */
    int16_t d1_reference_voltage_1_5_encode();

    /**
    * Decode member
    */
    double d1_reference_voltage_1_5_decode();

    /**
    * Is in range member
    */
    bool d1_reference_voltage_1_5_is_in_range();


    /**
    * Encode member
    */
    int16_t d2_reference_voltage_2_5_encode();

    /**
    * Decode member
    */
    double d2_reference_voltage_2_5_decode();

    /**
    * Is in range member
    */
    bool d2_reference_voltage_2_5_is_in_range();


    /**
    * Encode member
    */
    int16_t d3_reference_voltage_5_0_encode();

    /**
    * Decode member
    */
    double d3_reference_voltage_5_0_decode();

    /**
    * Is in range member
    */
    bool d3_reference_voltage_5_0_is_in_range();


    /**
    * Encode member
    */
    int16_t d4_reference_voltage_12_0_encode();

    /**
    * Decode member
    */
    double d4_reference_voltage_12_0_decode();

    /**
    * Is in range member
    */
    bool d4_reference_voltage_12_0_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M168_Flux_ID_IQ_Info.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m168_flux_id_iq_info_t:public CAN_STRUCT {
    /**
     * The commanded flux
     *
     * Range: -32768..32767 (-32.768..32.767 Wb)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t d1_flux_command;

    /**
     * The estimated flux
     *
     * Range: -32768..32767 (-32.768..32.767 Wb)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t d2_flux_feedback;

    /**
     * The measured Id current
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d3_id;

    /**
     * The measured Iq current
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d4_iq;

    /**
    * Encode member
    */
    int16_t d1_flux_command_encode();

    /**
    * Decode member
    */
    double d1_flux_command_decode();

    /**
    * Is in range member
    */
    bool d1_flux_command_is_in_range();


    /**
    * Encode member
    */
    int16_t d2_flux_feedback_encode();

    /**
    * Decode member
    */
    double d2_flux_feedback_decode();

    /**
    * Is in range member
    */
    bool d2_flux_feedback_is_in_range();


    /**
    * Encode member
    */
    int16_t d3_id_encode();

    /**
    * Decode member
    */
    double d3_id_decode();

    /**
    * Is in range member
    */
    bool d3_id_is_in_range();


    /**
    * Encode member
    */
    int16_t d4_iq_encode();

    /**
    * Decode member
    */
    double d4_iq_decode();

    /**
    * Is in range member
    */
    bool d4_iq_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M167_Voltage_Info.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m167_voltage_info_t:public CAN_STRUCT {
    /**
     * The actual measured value of the DC bus voltage
     *
     * Range: -32768..32767 (-3276.8..3276.7 V)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d1_dc_bus_voltage;

    /**
     * The calculated value of the output voltage, in peak line-neutral volts
     *
     * Range: -32768..32767 (-3276.8..3276.7 V)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d2_output_voltage;

    /**
     * Measured value of the voltage betwen phase A and Phase B
     *
     * Range: -32768..32767 (-3276.8..3276.7 V)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d3_vab_vd_voltage;

    /**
     * Measured value of the voltage between Phase B and Phase C
     *
     * Range: -32768..32767 (-3276.8..3276.7 V)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d4_vbc_vq_voltage;

    /**
    * Encode member
    */
    int16_t d1_dc_bus_voltage_encode();

    /**
    * Decode member
    */
    double d1_dc_bus_voltage_decode();

    /**
    * Is in range member
    */
    bool d1_dc_bus_voltage_is_in_range();


    /**
    * Encode member
    */
    int16_t d2_output_voltage_encode();

    /**
    * Decode member
    */
    double d2_output_voltage_decode();

    /**
    * Is in range member
    */
    bool d2_output_voltage_is_in_range();


    /**
    * Encode member
    */
    int16_t d3_vab_vd_voltage_encode();

    /**
    * Decode member
    */
    double d3_vab_vd_voltage_decode();

    /**
    * Is in range member
    */
    bool d3_vab_vd_voltage_is_in_range();


    /**
    * Encode member
    */
    int16_t d4_vbc_vq_voltage_encode();

    /**
    * Decode member
    */
    double d4_vbc_vq_voltage_decode();

    /**
    * Is in range member
    */
    bool d4_vbc_vq_voltage_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M166_Current_Info.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m166_current_info_t:public CAN_STRUCT {
    /**
     * The measured value of Phase A current
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d1_phase_a_current;

    /**
     * The measured value of Phase B current
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d2_phase_b_current;

    /**
     * The measured value of Phase C current
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d3_phase_c_current;

    /**
     * The Calculated DC Bus Current
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d4_dc_bus_current;

    /**
    * Encode member
    */
    int16_t d1_phase_a_current_encode();

    /**
    * Decode member
    */
    double d1_phase_a_current_decode();

    /**
    * Is in range member
    */
    bool d1_phase_a_current_is_in_range();


    /**
    * Encode member
    */
    int16_t d2_phase_b_current_encode();

    /**
    * Decode member
    */
    double d2_phase_b_current_decode();

    /**
    * Is in range member
    */
    bool d2_phase_b_current_is_in_range();


    /**
    * Encode member
    */
    int16_t d3_phase_c_current_encode();

    /**
    * Decode member
    */
    double d3_phase_c_current_decode();

    /**
    * Is in range member
    */
    bool d3_phase_c_current_is_in_range();


    /**
    * Encode member
    */
    int16_t d4_dc_bus_current_encode();

    /**
    * Decode member
    */
    double d4_dc_bus_current_decode();

    /**
    * Is in range member
    */
    bool d4_dc_bus_current_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M165_Motor_Position_Info.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m165_motor_position_info_t:public CAN_STRUCT {
    /**
     * The Electrical Angle of the motor as read by the encoder or resolver
     *
     * Range: 0..65535 (0..6553.5 deg)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t d1_motor_angle_electrical;

    /**
     * The measured speed of the motor
     *
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t d2_motor_speed;

    /**
     * The actual electrical frequency of the inverter
     *
     * Range: -32768..32767 (-3276.8..3276.7 hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d3_electrical_output_frequency;

    /**
     * Used in calibration of resolver angle adjustment.
     *
     * Range: -32768..32767 (-3276.8..3276.7 deg)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d4_delta_resolver_filtered;

    /**
    * Encode member
    */
    uint16_t d1_motor_angle_electrical_encode();

    /**
    * Decode member
    */
    double d1_motor_angle_electrical_decode();

    /**
    * Is in range member
    */
    bool d1_motor_angle_electrical_is_in_range();


    /**
    * Encode member
    */
    int16_t d2_motor_speed_encode();

    /**
    * Decode member
    */
    double d2_motor_speed_decode();

    /**
    * Is in range member
    */
    bool d2_motor_speed_is_in_range();


    /**
    * Encode member
    */
    int16_t d3_electrical_output_frequency_encode();

    /**
    * Decode member
    */
    double d3_electrical_output_frequency_decode();

    /**
    * Is in range member
    */
    bool d3_electrical_output_frequency_is_in_range();


    /**
    * Encode member
    */
    int16_t d4_delta_resolver_filtered_encode();

    /**
    * Decode member
    */
    double d4_delta_resolver_filtered_decode();

    /**
    * Is in range member
    */
    bool d4_delta_resolver_filtered_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M164_Digital_Input_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m164_digital_input_status_t:public CAN_STRUCT {
    /**
     * Status of Digital Input #1
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d1_digital_input_1;

    /**
     * Status of Digital Input #2
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d2_digital_input_2;

    /**
     * Status of Digital Input #3
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d3_digital_input_3;

    /**
     * Status of Digital Input #4
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d4_digital_input_4;

    /**
     * Status of Digital Input #5
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d5_digital_input_5;

    /**
     * Status of Digital Input #6
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d6_digital_input_6;

    /**
     * Status of Digital Input #7
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d7_digital_input_7;

    /**
     * Status of Digital Input #8
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d8_digital_input_8;

    /**
    * Encode member
    */
    uint8_t d1_digital_input_1_encode();

    /**
    * Decode member
    */
    double d1_digital_input_1_decode();

    /**
    * Is in range member
    */
    bool d1_digital_input_1_is_in_range();


    /**
    * Encode member
    */
    uint8_t d2_digital_input_2_encode();

    /**
    * Decode member
    */
    double d2_digital_input_2_decode();

    /**
    * Is in range member
    */
    bool d2_digital_input_2_is_in_range();


    /**
    * Encode member
    */
    uint8_t d3_digital_input_3_encode();

    /**
    * Decode member
    */
    double d3_digital_input_3_decode();

    /**
    * Is in range member
    */
    bool d3_digital_input_3_is_in_range();


    /**
    * Encode member
    */
    uint8_t d4_digital_input_4_encode();

    /**
    * Decode member
    */
    double d4_digital_input_4_decode();

    /**
    * Is in range member
    */
    bool d4_digital_input_4_is_in_range();


    /**
    * Encode member
    */
    uint8_t d5_digital_input_5_encode();

    /**
    * Decode member
    */
    double d5_digital_input_5_decode();

    /**
    * Is in range member
    */
    bool d5_digital_input_5_is_in_range();


    /**
    * Encode member
    */
    uint8_t d6_digital_input_6_encode();

    /**
    * Decode member
    */
    double d6_digital_input_6_decode();

    /**
    * Is in range member
    */
    bool d6_digital_input_6_is_in_range();


    /**
    * Encode member
    */
    uint8_t d7_digital_input_7_encode();

    /**
    * Decode member
    */
    double d7_digital_input_7_decode();

    /**
    * Is in range member
    */
    bool d7_digital_input_7_is_in_range();


    /**
    * Encode member
    */
    uint8_t d8_digital_input_8_encode();

    /**
    * Decode member
    */
    double d8_digital_input_8_decode();

    /**
    * Is in range member
    */
    bool d8_digital_input_8_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M163_Analog_Input_Voltages.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m163_analog_input_voltages_t:public CAN_STRUCT {
    /**
     * Voltage on Analog Input #1
     *
     * Range: 0..1023 (0..10.23 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t d1_analog_input_1;

    /**
     * Voltage on Analog Input #2
     *
     * Range: 0..1023 (0..10.23 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t d2_analog_input_2;

    /**
     * Voltage on Analog Input #3
     *
     * Range: 0..1023 (0..10.23 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t d3_analog_input_3;

    /**
     * Voltage on Analog Input #4
     *
     * Range: 0..1023 (0..10.23 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t d4_analog_input_4;

    /**
     * Voltage on Analog Input #5
     *
     * Range: 0..1023 (0..10.23 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t d5_analog_input_5;

    /**
     * Voltage on Analog Input #6
     *
     * Range: 0..1023 (0..10.23 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t d6_analog_input_6;

    /**
    * Encode member
    */
    uint16_t d1_analog_input_1_encode();

    /**
    * Decode member
    */
    double d1_analog_input_1_decode();

    /**
    * Is in range member
    */
    bool d1_analog_input_1_is_in_range();


    /**
    * Encode member
    */
    uint16_t d2_analog_input_2_encode();

    /**
    * Decode member
    */
    double d2_analog_input_2_decode();

    /**
    * Is in range member
    */
    bool d2_analog_input_2_is_in_range();


    /**
    * Encode member
    */
    uint16_t d3_analog_input_3_encode();

    /**
    * Decode member
    */
    double d3_analog_input_3_decode();

    /**
    * Is in range member
    */
    bool d3_analog_input_3_is_in_range();


    /**
    * Encode member
    */
    uint16_t d4_analog_input_4_encode();

    /**
    * Decode member
    */
    double d4_analog_input_4_decode();

    /**
    * Is in range member
    */
    bool d4_analog_input_4_is_in_range();


    /**
    * Encode member
    */
    uint16_t d5_analog_input_5_encode();

    /**
    * Decode member
    */
    double d5_analog_input_5_decode();

    /**
    * Is in range member
    */
    bool d5_analog_input_5_is_in_range();


    /**
    * Encode member
    */
    uint16_t d6_analog_input_6_encode();

    /**
    * Decode member
    */
    double d6_analog_input_6_decode();

    /**
    * Is in range member
    */
    bool d6_analog_input_6_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M162_Temperature_Set_3.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m162_temperature_set_3_t:public CAN_STRUCT {
    /**
     * RTD 4 (PT1000) Temperature (Gen 2 only)
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d1_rtd4_temperature;

    /**
     * RTD 5 (PT1000) Temperature (Gen 2 only)
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d2_rtd5_temperature;

    /**
     * Motor Temperature Sensor
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d3_motor_temperature;

    /**
     * Shudder compensation value of torque
     *
     * Range: -32768..32767 (-3276.8..3276.7 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d4_torque_shudder;

    /**
    * Encode member
    */
    int16_t d1_rtd4_temperature_encode();

    /**
    * Decode member
    */
    double d1_rtd4_temperature_decode();

    /**
    * Is in range member
    */
    bool d1_rtd4_temperature_is_in_range();


    /**
    * Encode member
    */
    int16_t d2_rtd5_temperature_encode();

    /**
    * Decode member
    */
    double d2_rtd5_temperature_decode();

    /**
    * Is in range member
    */
    bool d2_rtd5_temperature_is_in_range();


    /**
    * Encode member
    */
    int16_t d3_motor_temperature_encode();

    /**
    * Decode member
    */
    double d3_motor_temperature_decode();

    /**
    * Is in range member
    */
    bool d3_motor_temperature_is_in_range();


    /**
    * Encode member
    */
    int16_t d4_torque_shudder_encode();

    /**
    * Decode member
    */
    double d4_torque_shudder_decode();

    /**
    * Is in range member
    */
    bool d4_torque_shudder_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M161_Temperature_Set_2.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m161_temperature_set_2_t:public CAN_STRUCT {
    /**
     * Control Board Temperature
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d1_control_board_temperature;

    /**
     * RTD input 1 (PT1000) Temperature
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d2_rtd1_temperature;

    /**
     * RTD input 2 (PT1000) Temperature
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d3_rtd2_temperature;

    /**
     * RTD input 3 (PT1000) Temperature (Gen 2 only)
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d4_rtd3_temperature;

    /**
    * Encode member
    */
    int16_t d1_control_board_temperature_encode();

    /**
    * Decode member
    */
    double d1_control_board_temperature_decode();

    /**
    * Is in range member
    */
    bool d1_control_board_temperature_is_in_range();


    /**
    * Encode member
    */
    int16_t d2_rtd1_temperature_encode();

    /**
    * Decode member
    */
    double d2_rtd1_temperature_decode();

    /**
    * Is in range member
    */
    bool d2_rtd1_temperature_is_in_range();


    /**
    * Encode member
    */
    int16_t d3_rtd2_temperature_encode();

    /**
    * Decode member
    */
    double d3_rtd2_temperature_decode();

    /**
    * Is in range member
    */
    bool d3_rtd2_temperature_is_in_range();


    /**
    * Encode member
    */
    int16_t d4_rtd3_temperature_encode();

    /**
    * Decode member
    */
    double d4_rtd3_temperature_decode();

    /**
    * Is in range member
    */
    bool d4_rtd3_temperature_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M160_Temperature_Set_1.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m160_temperature_set_1_t:public CAN_STRUCT {
    /**
     * IGBT Module A Temperature
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d1_module_a;

    /**
     * IGBT Module B Temperature
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d2_module_b;

    /**
     * IGBT Module C Temperature
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d3_module_c;

    /**
     * Gate Driver Board Temperature
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t d4_gate_driver_board;

    /**
    * Encode member
    */
    int16_t d1_module_a_encode();

    /**
    * Decode member
    */
    double d1_module_a_decode();

    /**
    * Is in range member
    */
    bool d1_module_a_is_in_range();


    /**
    * Encode member
    */
    int16_t d2_module_b_encode();

    /**
    * Decode member
    */
    double d2_module_b_decode();

    /**
    * Is in range member
    */
    bool d2_module_b_is_in_range();


    /**
    * Encode member
    */
    int16_t d3_module_c_encode();

    /**
    * Decode member
    */
    double d3_module_c_decode();

    /**
    * Is in range member
    */
    bool d3_module_c_is_in_range();


    /**
    * Encode member
    */
    int16_t d4_gate_driver_board_encode();

    /**
    * Decode member
    */
    double d4_gate_driver_board_decode();

    /**
    * Is in range member
    */
    bool d4_gate_driver_board_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M174_Firmware_Info.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m174_firmware_info_t:public CAN_STRUCT {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t d1_project_code_eep_ver;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t d2_sw_version;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t d3_date_code_mmdd;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t d4_date_code_yyyy;

    /**
    * Encode member
    */
    uint16_t d1_project_code_eep_ver_encode();

    /**
    * Decode member
    */
    double d1_project_code_eep_ver_decode();

    /**
    * Is in range member
    */
    bool d1_project_code_eep_ver_is_in_range();


    /**
    * Encode member
    */
    uint16_t d2_sw_version_encode();

    /**
    * Decode member
    */
    double d2_sw_version_decode();

    /**
    * Is in range member
    */
    bool d2_sw_version_is_in_range();


    /**
    * Encode member
    */
    uint16_t d3_date_code_mmdd_encode();

    /**
    * Decode member
    */
    double d3_date_code_mmdd_decode();

    /**
    * Is in range member
    */
    bool d3_date_code_mmdd_is_in_range();


    /**
    * Encode member
    */
    uint16_t d4_date_code_yyyy_encode();

    /**
    * Decode member
    */
    double d4_date_code_yyyy_decode();

    /**
    * Is in range member
    */
    bool d4_date_code_yyyy_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M175_Diag_Data.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m175_diag_data_t:public CAN_STRUCT {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d1_buffer_record;

    /**
     * Range: 0..5 (0..5 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d2_buffer_segment;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t d3_diag_data_1;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t d4_diag_data_2;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t d5_diag_data_3;

    /**
    * Encode member
    */
    uint8_t d1_buffer_record_encode();

    /**
    * Decode member
    */
    double d1_buffer_record_decode();

    /**
    * Is in range member
    */
    bool d1_buffer_record_is_in_range();


    /**
    * Encode member
    */
    uint8_t d2_buffer_segment_encode();

    /**
    * Decode member
    */
    double d2_buffer_segment_decode();

    /**
    * Is in range member
    */
    bool d2_buffer_segment_is_in_range();


    /**
    * Encode member
    */
    int16_t d3_diag_data_1_encode();

    /**
    * Decode member
    */
    double d3_diag_data_1_decode();

    /**
    * Is in range member
    */
    bool d3_diag_data_1_is_in_range();


    /**
    * Encode member
    */
    int16_t d4_diag_data_2_encode();

    /**
    * Decode member
    */
    double d4_diag_data_2_decode();

    /**
    * Is in range member
    */
    bool d4_diag_data_2_is_in_range();


    /**
    * Encode member
    */
    int16_t d5_diag_data_3_encode();

    /**
    * Decode member
    */
    double d5_diag_data_3_decode();

    /**
    * Is in range member
    */
    bool d5_diag_data_3_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M187_U2C_Command_Txd.
 *
 * Enable message sent to Delphi DC/DC converter.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m187_u2_c_command_txd_t:public CAN_STRUCT {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d1_id_byte;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d2_setpoint_calc;

    /**
    * Encode member
    */
    uint8_t d1_id_byte_encode();

    /**
    * Decode member
    */
    double d1_id_byte_decode();

    /**
    * Is in range member
    */
    bool d1_id_byte_is_in_range();


    /**
    * Encode member
    */
    uint8_t d2_setpoint_calc_encode();

    /**
    * Decode member
    */
    double d2_setpoint_calc_decode();

    /**
    * Is in range member
    */
    bool d2_setpoint_calc_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M188_U2C_Message_Rxd.
 *
 * Response from Delphi DC/DC converter.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m188_u2_c_message_rxd_t:public CAN_STRUCT {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d1_hv_input_current_sensor_validity;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d2_14_v_master_fault;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d3_hv_input_current;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d4_dtc_status;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d5_dtc_index;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d6_14_v_monitor;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d7_14_v_conditional;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t d8_14_v_current_monitor;

    /**
    * Encode member
    */
    uint8_t d1_hv_input_current_sensor_validity_encode();

    /**
    * Decode member
    */
    double d1_hv_input_current_sensor_validity_decode();

    /**
    * Is in range member
    */
    bool d1_hv_input_current_sensor_validity_is_in_range();


    /**
    * Encode member
    */
    uint8_t d2_14_v_master_fault_encode();

    /**
    * Decode member
    */
    double d2_14_v_master_fault_decode();

    /**
    * Is in range member
    */
    bool d2_14_v_master_fault_is_in_range();


    /**
    * Encode member
    */
    uint8_t d3_hv_input_current_encode();

    /**
    * Decode member
    */
    double d3_hv_input_current_decode();

    /**
    * Is in range member
    */
    bool d3_hv_input_current_is_in_range();


    /**
    * Encode member
    */
    uint8_t d4_dtc_status_encode();

    /**
    * Decode member
    */
    double d4_dtc_status_decode();

    /**
    * Is in range member
    */
    bool d4_dtc_status_is_in_range();


    /**
    * Encode member
    */
    uint8_t d5_dtc_index_encode();

    /**
    * Decode member
    */
    double d5_dtc_index_decode();

    /**
    * Is in range member
    */
    bool d5_dtc_index_is_in_range();


    /**
    * Encode member
    */
    uint8_t d6_14_v_monitor_encode();

    /**
    * Decode member
    */
    double d6_14_v_monitor_decode();

    /**
    * Is in range member
    */
    bool d6_14_v_monitor_is_in_range();


    /**
    * Encode member
    */
    uint8_t d7_14_v_conditional_encode();

    /**
    * Decode member
    */
    double d7_14_v_conditional_decode();

    /**
    * Is in range member
    */
    bool d7_14_v_conditional_is_in_range();


    /**
    * Encode member
    */
    uint8_t d8_14_v_current_monitor_encode();

    /**
    * Decode member
    */
    double d8_14_v_current_monitor_decode();

    /**
    * Is in range member
    */
    bool d8_14_v_current_monitor_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message BMS_Current_Limit.
 *
 * Message sent by BMS for inverter DC current limiting.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_bms_current_limit_t:public CAN_STRUCT {
    /**
     * Maximum discharge current from BMS
     *
     * Range: 0..1000 (0..1000 A)
     * Scale: 1
     * Offset: 0
     */
    uint16_t d1_max_discharge_current;

    /**
     * Maximum charge current from BMS
     *
     * Range: 0..1000 (0..1000 A)
     * Scale: 1
     * Offset: 0
     */
    uint16_t d2_max_charge_current;

    /**
    * Encode member
    */
    uint16_t d1_max_discharge_current_encode();

    /**
    * Decode member
    */
    double d1_max_discharge_current_decode();

    /**
    * Is in range member
    */
    bool d1_max_discharge_current_is_in_range();


    /**
    * Encode member
    */
    uint16_t d2_max_charge_current_encode();

    /**
    * Decode member
    */
    double d2_max_charge_current_decode();

    /**
    * Is in range member
    */
    bool d2_max_charge_current_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};
/**
 * Signals in message M176_Fast_Info.
 *
 * To enable fast message set CAN ACTIVE MSGS HI WORD to 0xFFFE.  Setting to default value of 0xFFFF will disable the fast message.
 *
 * All signal values are as on the CAN bus.
 */
struct dbc_rms_m176_fast_info_t:public CAN_STRUCT {
    /**
     * The commanded torque
     *
     * Range: -32768..32767 (-3276.8..3276.7 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t fast_torque_command;

    /**
     * The estimated torque
     *
     * Range: -32768..32767 (-3276.8..3276.7 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t fast_torque_feedback;

    /**
     * Motor speed
     *
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t fast_motor_speed;

    /**
     * DC Bus Voltage
     *
     * Range: -32768..32767 (-3276.8..3276.7 V)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t fast_dc_bus_voltage;

    /**
    * Encode member
    */
    int16_t fast_torque_command_encode();

    /**
    * Decode member
    */
    double fast_torque_command_decode();

    /**
    * Is in range member
    */
    bool fast_torque_command_is_in_range();


    /**
    * Encode member
    */
    int16_t fast_torque_feedback_encode();

    /**
    * Decode member
    */
    double fast_torque_feedback_decode();

    /**
    * Is in range member
    */
    bool fast_torque_feedback_is_in_range();


    /**
    * Encode member
    */
    int16_t fast_motor_speed_encode();

    /**
    * Decode member
    */
    double fast_motor_speed_decode();

    /**
    * Is in range member
    */
    bool fast_motor_speed_is_in_range();


    /**
    * Encode member
    */
    int16_t fast_dc_bus_voltage_encode();

    /**
    * Decode member
    */
    double fast_dc_bus_voltage_decode();

    /**
    * Is in range member
    */
    bool fast_dc_bus_voltage_is_in_range();


    /**
    * Pack member
    */
    int pack(uint8_t *dst_p, size_t size);
    
    /**
    * Unpack member
    */
    int unpack(const uint8_t *dst_p, size_t size);

};

#ifdef __cplusplus
}
#endif

#endif
